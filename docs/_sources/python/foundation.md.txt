# Python基礎

Python そのものと、標準で同梱されるモジュールについて、ここに含める。

## Debian 10 (buster) に Python 3.9.7 をインストールする。

```bash
sudo -i

apt update
apt install build-essential zlib1g-dev libssl-dev libffi-dev

cd /usr/local/src
curl -Lo Python-3.9.7.tar.xz https://www.python.org/ftp/python/3.9.7/Python-3.9.7.tar.xz
tar -Jxvf Python-3.9.7.tar.xz

cd /usr/local/src/Python-3.9.7
./configure --enable-optimizations --prefix=/usr/local/python-3.9.7
make
make altinstall
```

```bash
sudo update-alternatives --install /usr/local/bin/python3 python3 /usr/local/python-3.9.7/bin/python3.9 10
```

[Getting and installing the latest version of Python](https://docs.python.org/3.9/using/unix.html#on-linux)を参照した。

## ビット演算を行う。

```python
x = 0b1010
y = 0b1100
print('x      = {:08b}'.format(x))
print('y      = {:08b}'.format(y))
print('x << 1 = {:08b}'.format(x << 1)) # bit shift
print('x >> 1 = {:08b}'.format(x >> 1)) # bit shift
print('x & y  = {:08b}'.format(x & y))  # AND
print('x | y  = {:08b}'.format(x | y))  # OR
print('x ^ y  = {:08b}'.format(x ^ y))  # XOR
```

```console
>>> x = 0b1010
>>> y = 0b1100
>>> print('x      = {:08b}'.format(x))
x      = 00001010
>>> print('y      = {:08b}'.format(y))
y      = 00001100
>>> print('x << 1 = {:08b}'.format(x << 1)) # bit shift
x << 1 = 00010100
>>> print('x >> 1 = {:08b}'.format(x >> 1)) # bit shift
x >> 1 = 00000101
>>> print('x & y  = {:08b}'.format(x & y))  # AND
x & y  = 00001000
>>> print('x | y  = {:08b}'.format(x | y))  # OR
x | y  = 00001110
>>> print('x ^ y  = {:08b}'.format(x ^ y))  # XOR
x ^ y  = 00000110
```

## ファンクションに定義されていない引数を与える。

```python
def f(arg1):
    pass


f(arg1=1, arg2=2)
```

```console
>>> f(arg1=1, arg2=2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: f() got an unexpected keyword argument 'arg2'
```

## ファンクションに同一の引数を複数回指定する。

```python
def f(arg1):
    print(kwargs)


f(arg1=1, arg1=2)
```

```console
>>> f(arg1=1, arg1=2)
  File "<stdin>", line 1
SyntaxError: keyword argument repeated: arg1
```

## ファンクションにディクショナリで引数を指定する。

```python
def f(arg1):
    print(arg1)


kwargs = {'arg1': 1}
f(**kwargs)
```

```console
>>> f(**kwargs)
1
```
## ファンクションで任意長の引数を受ける。

```python
def f(arg1, **kwargs):
    print(kwargs)


f(arg1=1, arg2=2)
f(arg1=1, **{"arg2": 2})
f(arg1=1, **{"arg2": 2, "arg1": 3})
```

```console
>>> f(arg1=1, arg2=2)
{'arg2': 2}
>>> f(arg1=1, **{"arg2": 2})
{'arg2': 2}
>>> f(arg1=1, **{"arg2": 2, "arg1": 3})
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: __main__.f() got multiple values for keyword argument 'arg1'
```

## utf-8 でエンコードされたとき何バイトかを得る。

```python
len('あ'.encode('utf-8'))
```

```console
>>> len('あ'.encode('utf-8'))
3
```

## Unicode のコードポイントを得る。

```python
def get_fileformat_info_url(cp: int):
    return 'https://www.fileformat.info/info/unicode/char/{:x}/index.htm'.format(cp)


string = 'あ'
#string = '禰󠄀'

for ch in list(string):
    cp = ord(ch)
    print('U+{:x}'.format(cp))
    print(get_fileformat_info_url(cp))
```

```console
>>> string = 'あ'
>>> for ch in list(string):
...     cp = ord(ch)
...     print('U+{:x}'.format(cp))
...     print(get_fileformat_info_url(cp))
...
U+3042
https://www.fileformat.info/info/unicode/char/3042/index.htm
```

https://docs.python.org/3/library/functions.html#ord

## logging でロガーを利用する。

```python
import logging


# ルートロガーの設定は、すべてのロガーに影響するので利用を回避する。
# 回避するために、ルートロガーではないロガーを得る。
# 一般的に、モジュール名をロガー名に使う。
logger = logging.getLogger(__name__)

# レベルは、ロガーとハンドラーの両方で設定する。
logger.setLevel(logging.DEBUG)
handler = logging.StreamHandler()
handler.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s %(name)s %(levelname)s %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)
```

## IPアドレスを計算する。

https://github.com/kumarstack55/python-ipv4calc

```console
PS > poetry run ipv4calc 192.168.0.1/24
address         : 192.168.0.1
network         : 192.168.0.0
netmask         : 255.255.255.0
broadcast       : 192.168.0.255
addressPrefix   : 24
numAddresses    : 256
addressBinary   : 11000000.10101000.00000000.00000001
networkBinary   : 11000000.10101000.00000000.00000000
netmaskBinary   : 11111111.11111111.11111111.00000000
broadcastBinary : 11000000.10101000.00000000.11111111
```

## argparse でファイルのエンコーディングを指定する。

指定なしの場合、環境によっては cp932 が選択されることがある。
対象のエンコーディングがわかっていれば、明示的に指定したほうがよい。

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('--f1', type=argparse.FileType('w'))
parser.add_argument('--f2', type=argparse.FileType('w', encoding='UTF-8'))
parser.add_argument('--f3', type=argparse.FileType('r'))
parser.add_argument('--f4', type=argparse.FileType('r', encoding='UTF-8'))
args1 = ['--f1', '1.txt', '--f2', '2.txt', '--f3', '3.txt', '--f4', '4.txt']
args2 = parser.parse_args(args1)

args2.f1
args2.f2
args2.f3
args2.f4
```

```console
PS > (Get-WmiObject Win32_OperatingSystem).Version
10.0.22000
```

```console
PS > python --version
Python 3.9.4
```

```console
>>> args2.f1
<_io.TextIOWrapper name='1.txt' mode='w' encoding='cp932'>
>>> args2.f2
<_io.TextIOWrapper name='2.txt' mode='w' encoding='UTF-8'>
>>> args2.f3
<_io.TextIOWrapper name='3.txt' mode='r' encoding='cp932'>
>>> args2.f4
<_io.TextIOWrapper name='4.txt' mode='r' encoding='UTF-8'>
```

## functools で既存関数の一部の変数を指定した関数相当を作る。

```python
#!/usr/bin/env python3
from functools import partial
import sys


debug_print = partial(print, file=sys.stderr)
print("stdout")
debug_print("stderr")
```

```bash
./a.py
./a.py >/dev/null
```

```console
$ ./a.py
stdout
stderr
```

```console
$ ./a.py >/dev/null
stderr
```
